<font size = 3>



# 复杂度分析
![](https://img2020.cnblogs.com/blog/1755696/202004/1755696-20200405204623067-772577567.png)

 
![](https://img2020.cnblogs.com/blog/1755696/202004/1755696-20200405204607306-1480920133.png)


# 一、比较类排序
通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。

## 1.插入排序

>  遍历数组，不断将当前值与数组的前缀元素进行比较，如果比它小，就交换。
*对于近乎有序的数组，插入排序相当有效。*
> 要知道，一次交换就是三次赋值运算。
> 插入排序经常作为其他排序的子过程。

### 1.1 简单插入排序
- 插入排序有一个往后挪动的过程
- 记录一个preIndex是当前i值的前一个，不断减小preIndex，往前挪

### 1.2 希尔排序
- 希尔排序有一个增量的概念，它是通过不断缩小增量的值，来进行挪动。
```
10 9 8 6 5 3 1 2 4 7
3 1 2 4 5 10 9 8 6 7  gap = 5 
2 1 3 4 5 7 6 8 9 10  gap = 2
1 2 3 4 5 6 7 8 9 10  gap =1
```
## 2.选择排序
### 2.1 简单选择排序
- 遍历整个数组，从数组中剩下的元素中选择出一个最小的与当前的元素进行交换。不断选择出最小的。
- 空间复杂度为O(1)



### 2.2 堆排序

堆是具有以下性质的完全二叉树：

- 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；
- 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。


对于节点i:
- 父节点是[i/2]
- 左孩子：2i
- 右孩子：2i+1
- 最后一个非叶节点是[n/2],所以叶节点是从[n/2]+1 ~ n
![](https://img2020.cnblogs.com/blog/1755696/202005/1755696-20200526110440761-1662276843.png)

基本思想：
- 将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。


用公式描述如下：
- 大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2] 
- 小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]  

总结：
- 堆排序的时间复杂度是： O(n*logn)，且不稳定
- 初始化建堆的时间复杂度为O(n)，排序重建堆的时间复杂度为nlog(n)，所以总的时间复杂度为O(n+nlogn)=O(nlogn)。另外堆排序的比较次数和序列的初始状态有关，但只是在序列初始状态为堆的情况下比较次数显著减少，在序列有序或逆序的情况下比较次数不会发生明显变化。

[小顶堆实现](https://github.com/ccpang96/sort/blob/master/sort/heapLittleSort.h) </br>
[大顶堆实现](https://github.com/ccpang96/sort/blob/master/sort/heapBigSort.h) </br>


## 3.交换排序
### 3.1 冒泡排序
- 冒泡排序是稳定的
- 最好时间复杂度是O(n)
- 空间复杂度为O(1) temp变量

### 3.2 快速排序

- 快速排序不稳定 10 10 3 10 4 5 6 当遍历到4时，第二个10就会跑到第三个10 的前边。 
- 最坏时间复杂度为O(n2),当数组本身为有序时，这时基准一直是最后一个数。另一个分支没有了。 n次递归*n次比较
- 空间复杂读为O(n*logn): partition时需要交换n次，交换需要一个temp变量，这样的递归过程一共需要执行logn次。



## 4.归并排序
### 4.1 二路归并排序


### 4.2 多路归并排序

 
# 二、非比较类排序
不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。
## 1.1 计数排序
将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数

- 计数排序就是先开匹配一个大小为maxValue+1的新数组，然后依次遍历数组arr,统计每个数组出现的次数，并将其值保存到bucket数组中。最后将bucket数组中的值，附给原数组。


## 1.2 桶排序
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

- 桶排序需要考虑桶的数量，并且用取余的方法将数映射到桶中，再对每个桶内的数调用某种排序算法进行排序，最后将桶中的数依次复制到原数组。

## 1.3 基数排序
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。


# 参考文献
[知乎介绍](https://www.zhihu.com/search?type=content&q=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95) </br>
[算法图形化网站](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)</br>
[堆排序](https://www.cnblogs.com/chengxiao/p/6129630.html) </br>
 </font>